package org.mitre.taxii.messages.xml11;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;

/**
 * This class replicates the Python libtaxii to_text() output.
 * 
 * The cleaner way to implement this would be for each TAXII class have a toText()
 * method. However, the TAXII classes are generated by XJC and I would much rather
 * avoid post-processing the generated code.
 * 
 * @author jasenj1
 */
public class PythonTextOutput {
    private static final String STD_INDENT = "  "; // A "Standard Indent" to use for to_text() methods
    
    public static String toText(Object obj) {
        return toText(obj,"");        
    }

    public static String toText(Object obj, String line_prepend) {
        String s = new String();
        if (null == line_prepend) {
            line_prepend = "";
        }
        
        if (obj instanceof SupportedQueryType) {
            SupportedQueryType self = (SupportedQueryType) obj;
            s = line_prepend + "=== Supported Query Information ===\n";
            s += line_prepend + String.format("  Query Format: %s\n", self.getFormatId());
            return s;
        }
        
        if (obj instanceof QueryType) {
            QueryType self = (QueryType) obj;
            s = line_prepend + "=== Query ===\n";
            s += line_prepend + String.format("  Query Format: %s\n", self.getFormatId());
            return s;
        }
        
        if (obj instanceof ContentBindingIDType) {
            ContentBindingIDType self = (ContentBindingIDType)obj;
            s = line_prepend;
            s += self.getBindingId();
            if (!self.getSubtypes().isEmpty()) {
                List<String> subtypes = new ArrayList();
                for (SubtypeType st : self.getSubtypes()) {
                    subtypes.add(st.getSubtypeId());
                }                
                s += ">" + join(",",subtypes);
            }            
            return s;
        }
        
        if (obj instanceof RecordCountType) {
            RecordCountType self = (RecordCountType)obj;
            s = line_prepend + "=== Record Count ===\n";
            s += line_prepend + String.format("  Record Count: %s\n", self.getValue());
            s += line_prepend + String.format("  Partial Count: %s\n", self.isPartialCount());            
            return s;
        }
        
        // TODO: GenericParameters
        
        if (obj instanceof ContentBlock) {
            ContentBlock self = (ContentBlock)obj;
            
            s = line_prepend + "=== Content Block ===\n";
            s += line_prepend + String.format("  Content Binding: %s\n", toText(self.getContentBinding(), ""));

            /* TODO: On the Python side the below is the length of the marshaled/serialized content.
                libtaxii stores the content internally as a string. On the Java side the content is
                a list of objects (see AnyMixedContentType). So to really get the
                length would require marshaling the content - an expensive operation
                that requires a TaxiiXml object with the proper JAXB context.
                i.e. It's a pain to do. Skip it for now.
            */
            s += line_prepend + String.format("  Content length: %s\n", "unknown");
                        
            s += line_prepend + "  (Content not printed for brevity)\n";
            if (null != self.getTimestampLabel()) {
                s += line_prepend + String.format("  Timestamp Label: %s\n",self.getTimestampLabel().toXMLFormat());
            }
            s += line_prepend + String.format("  Padding: %s\n",self.getPadding());
            
            return s;            
        }

        if (obj instanceof PushParameterType) {
            PushParameterType self = (PushParameterType) obj;
            s = line_prepend + "=== Push Parameters ===\n";
            s += line_prepend + String.format("  Protocol Binding: %s\n", self.getProtocolBinding());
            s += line_prepend + String.format("  Inbox Address: %s\n", self.getAddress());
            s += line_prepend + String.format("  Message Binding: %s\n",self.getMessageBinding());            
            return s;
        }
        
        /*
            And here we see the problem with this approach. MessageType is a common
            ancestor for all messages. What happens when an object is an instanceof 
            multiple class types?
            Should the ifs be stacked from most specific to least specific type?
            That's going to be a pain to track.
        */
        if (obj instanceof MessageType) {
            MessageType self = (MessageType) obj;

            XmlRootElement root = self.getClass().getAnnotation(XmlRootElement.class);
            s = line_prepend + String.format("Message Type: %s\n", root.name());
            s += line_prepend + String.format("Message ID: %s", self.getMessageId());
            if (self instanceof ResponseMessageType) {       
                ResponseMessageType rmt = (ResponseMessageType)self;                
                s += String.format("; In Response To: %s", rmt.getInResponseTo());
            }
            s += "\n";
                    
            ExtendedHeadersType eht = self.getExtendedHeaders();
            if (null != eht) {
                List<ExtendedHeaderType> ehtList = eht.getExtendedHeaders();
                for (ExtendedHeaderType eh : ehtList) {
                    // TODO: Note, this is another case where the Python stores the value as a string, but it really is AnyMixedContentType (See ContentBlockType above).
                    s += line_prepend + String.format("Extended Header: %s = %s\n", eh.getName(), "unknown");
                }                
            }                
            // Intentional fall through. MessageType is a superclass of many other message types.
            // return s; 
        }
        
        if (obj instanceof DiscoveryResponse) {
            DiscoveryResponse self = (DiscoveryResponse)obj;
            // s is populated by MessageType match already.
            for( ServiceInstanceType si : self.getServiceInstances()) {
                s += toText(si, line_prepend + STD_INDENT);                
            }
            return s;
        }
        
        if (obj instanceof ServiceInstanceType) {
            ServiceInstanceType self = (ServiceInstanceType)obj;
            s = line_prepend +  "=== Service Instance ===\n";
            s += line_prepend +  String.format("  Service Type: %s\n", self.getServiceType().name());
            s += line_prepend +  String.format("  Service Version: %s\n", self.getServiceVersion());
            s += line_prepend +  String.format("  Protocol Binding: %s\n", self.getProtocolBinding());
            s += line_prepend +  String.format("  Service Address: %s\n", self.getAddress());
            
            for (String mb : self.getMessageBindings()) {
                s += line_prepend +  String.format("  Message Binding: %s\n", mb);
            }

            for (ContentBindingIDType cb : self.getContentBindings()) {
                s += line_prepend + String.format("  Inbox Service AC: %s\n", toText(cb, line_prepend));
            }
            
            s += line_prepend +  String.format("  Available: %s\n", self.isAvailable());
            s += line_prepend +  String.format("  Message: %s\n",self.getMessage());
            
            for (SupportedQueryType q : self.getSupportedQueries()) {
                s += toText(q, line_prepend + STD_INDENT);
            }
            return s;            
        }

        if (obj instanceof CollectionInformationResponse) {
            CollectionInformationResponse self = (CollectionInformationResponse) obj;
            // s is populated by MessageType match already.
            
            s += line_prepend + String.format("Contains %s Collection Informations\n", self.getCollections().size());
            for(CollectionRecordType crt : self.getCollections()) {
                s += toText(crt, line_prepend + STD_INDENT);
            }
            return s;
        }
        
        if (obj instanceof CollectionRecordType) {
            CollectionRecordType self = (CollectionRecordType) obj;
            
            return s;
        }
        
        s = "Sorry, I do not know how to render a " + obj.getClass().getName();
        return s;
    }
    
    /**
     * Implement my own join() method. Java 8 does this out of the box, and
     * many libraries implement it too (Apache's StringUtil). But in an attempt
     * to reduce dependencies and support as many versions of Java as possible,
     * I'll write my own here.
     * 
     * @return 
     */
    private static String join(String separator, List<String> list) {
        if (null == list) return null;
        
        int size = list.size();        
        if (0 == size) return null;
        StringBuilder sb = new StringBuilder();
        
        sb.append(list.get(0));
        for(int x = 1; x < size; ++x) {
            sb.append(separator).append(list.get(x));
        }
        
        return sb.toString();
    }
    
}
